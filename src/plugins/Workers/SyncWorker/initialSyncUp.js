const EVENTS = require('../../../EVENTS');
const logger = require('../../../logger');

// This method is called as first thing by the SyncWorker.
// It's only when resolved that the Wallet will be ready (for what SyncWorker do)
// And therefore that's where we need to deal with all necessary step
// such as fetching all UTXO and previous TX.
//
// It should deal with additional addresses generated by a BIP44 Worker if
// fetching here found that we have more addresses that on starting of the sync up.
module.exports = async function initialSyncUp() {
  const self = this;

  // Due to the events system, we need to handle the fact that we did subscribed to addresses
  // that we had received the transactions and store before
  // being able to release initialSyncUp as ready.
  // When we will move to bloomfilter, that part might be more complex.
  return new Promise((resolve) => {
    const addrList = this.getAddressListToSync().map((addr) => addr.address);
    const expectedAddrNumberToFetch = addrList.length;

    let expectedTxNumberToFetch = 0;
    let numberOfFetchedTx = 0;
    let fetchedAddresses = 0;
    logger.silly(`SyncWorker - initialSyncUp - addr fetched : ${fetchedAddresses}/${expectedAddrNumberToFetch}`);

    const waiterTxFetchedListernerFn = async () => {
      numberOfFetchedTx += 1;
      logger.silly(`SyncWorker - init txWaiter : fetched : ${numberOfFetchedTx}/${expectedTxNumberToFetch}`);
      if (numberOfFetchedTx >= expectedTxNumberToFetch) {
        self.transporter.removeListener(EVENTS.FETCHED_TRANSACTION, waiterTxFetchedListernerFn);
        resolve(true);
      }
    };
    this.transporter.on(EVENTS.FETCHED_TRANSACTION, waiterTxFetchedListernerFn);

    const waiterAddressFetchedListenerFn = async (ev) => {
      const { payload: address } = ev;

      fetchedAddresses += 1;

      expectedTxNumberToFetch += address.utxos.length;
      logger.silly(`SyncWorker - init addrWaiter : fetched : ${fetchedAddresses}/${expectedAddrNumberToFetch}`);

      if (fetchedAddresses >= expectedAddrNumberToFetch) {
        logger.silly(`SyncWorker - initialSyncUp - tx fetched : ${numberOfFetchedTx}/${expectedTxNumberToFetch}`);
        if (expectedTxNumberToFetch === 0) {
          self.transporter.removeListener(EVENTS.FETCHED_TRANSACTION, waiterTxFetchedListernerFn);
          resolve(true);
        }
        self.transporter.removeListener(EVENTS.FETCHED_ADDRESS, waiterAddressFetchedListenerFn);
      }
    };
    this.transporter.on(EVENTS.FETCHED_ADDRESS, waiterAddressFetchedListenerFn);

    let txFetching = 0;
    this.transporter.on(EVENTS.FETCHED_TRANSACTION, () => txFetching += 1);
    this.transporter.subscribeToAddressesTransactions(addrList);
  });
};
