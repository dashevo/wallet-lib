const logger = require('../../../logger');
const fetchAddressTransactions = require('./utils/fetchAddressTransactions');
const TransactionOrderer = require('./utils/TransactionOrderer/TransactionOrderer');
// This method is called as first thing by the SyncWorker.
// It's only when resolved that the Wallet will be ready (for what SyncWorker do)
// And therefore that's where we need to deal with all necessary step
// such as fetching all UTXO and previous TX.
//
// It should deal with additional addresses generated by a BIP44 Worker if
// fetching here found that we have more addresses that on starting of the sync up.
module.exports = async function initialSyncUp() {
  const { transporter, storage } = this;
  const addrList = this.getAddressListToSync().map((addr) => addr.address);

  // Due to the events system, we need to handle the fact that we did subscribed to addresses
  // that we had received the transactions and store before
  // being able to release initialSyncUp as ready.
  // When we will move to bloomfilter, that part might be more complex.
  /* eslint-disable-next-line no-async-promise-executor */
  const promises = [];
  addrList.forEach((address) => {
    promises.push(fetchAddressTransactions(address, transporter));
  });

  let transactions = [];

  const fetchedPromises = await Promise.all(promises);

  fetchedPromises.forEach((fetchedTransactions) => {
    transactions = transactions.concat(fetchedTransactions);
  });

  const ordered = new TransactionOrderer();

  transactions.forEach((tx) => ordered.insert(tx));

  const importPromises = [];
  ordered.transactions.forEach((orderTransaction) => {
    importPromises.push(storage.importTransaction(orderTransaction));
  });

  return Promise.all(importPromises).then(() => logger.silly('SyncWorker - initialSyncUp - Fully synced'));
};
